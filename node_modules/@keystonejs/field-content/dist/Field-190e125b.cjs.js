'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

require("@babel/runtime/helpers/objectWithoutProperties");

var slate = require('slate');

var _extends = _interopDefault(require("@babel/runtime/helpers/extends"));

var core = require('@emotion/core');

var utils = require('./utils-78f44ec7.cjs.js');

var icons = require('@arch-ui/icons');

var theme = require('@arch-ui/theme');

require('@arch-ui/color-utils');

require('@arch-ui/tooltip');

require('@arch-ui/typography');

var toolbarComponents = require('./toolbar-components-f4fe90f0.cjs.js');

var React = require('react');

var React__default = _interopDefault(React);

var paragraph = require('./paragraph-07189f43.cjs.js');

var reactPopper = require('react-popper');

var index = require('./index-7c597167.cjs.js');

var slateReact = require('slate-react');

var reactDom = require('react-dom');

var isHotkey = _interopDefault(require('is-hotkey'));

var getSelectionRange = require('get-selection-range');

var hooks = require('@arch-ui/hooks');

var applyRef = _interopDefault(require('apply-ref'));

var fields = require('@arch-ui/fields');

var input = require('@arch-ui/input');

function markPlugin(type, options) {
  return {
    onKeyDown(event, editor, next) {
      // If it doesn't match our `key`, let other plugins handle it.
      if (!options.test(event)) return next(); // Prevent the default characters from being inserted.

      event.preventDefault(); // Toggle the mark `type`.

      editor.toggleMark(type);
    },

    renderMark: (props, editor, next) => {
      if (props.mark.type === type) {
        return options.render(props);
      }

      return next();
    }
  };
}

let marks = {
  bold: {
    test: isHotkey('mod+b'),
    label: 'Bold',
    icon: props => {
      return React__default.createElement("strong", _extends({}, props, {
        "aria-hidden": true
      }), "B");
    },
    render: props => React__default.createElement("strong", props.attributes, props.children)
  },
  italic: {
    test: isHotkey('mod+i'),
    label: 'Italic',
    icon: props => {
      return React__default.createElement("em", _extends({}, props, {
        "aria-hidden": true
      }), "I");
    },
    render: props => React__default.createElement("em", props.attributes, props.children)
  },
  strikethrough: {
    test: isHotkey('mod+~'),
    label: 'Strikethrough',
    icon: props => {
      return React__default.createElement("s", _extends({}, props, {
        "aria-hidden": true
      }), "S");
    },
    render: props => React__default.createElement("s", props.attributes, props.children)
  },
  underline: {
    test: isHotkey('mod+u'),
    label: 'Underline',
    icon: props => {
      return React__default.createElement("u", _extends({}, props, {
        "aria-hidden": true
      }), "U");
    },
    render: props => React__default.createElement("u", props.attributes, props.children)
  }
};
let markTypes = Object.keys(marks);
let plugins = Object.entries(marks).map(_ref => {
  let [type, options] = _ref;
  return markPlugin(type, options);
});
/** @jsx jsx */

let AddBlock = _ref => {
  let {
    editorState,
    editor,
    blocks
  } = _ref;
  let windowSize = index.useWindowSize();
  let openCloseRef = React.useRef(null);
  let containerRef = React.useRef(null);
  let focusBlock = editorState.focusBlock;
  let layout = React.useCallback(() => {
    let openCloseEle = openCloseRef.current;
    let containerEle = containerRef.current;
    const rect = getSelectionRange.getVisibleSelectionRect();

    if (!rect || rect.width !== 0 || focusBlock === null || focusBlock.text !== '' || focusBlock.type !== paragraph.type) {
      setIsOpen(false);
      openCloseEle.style.top = '';
      openCloseEle.style.left = '';
      containerEle.style.top = '';
      containerEle.style.left = '';
      return;
    }

    const top = rect.top + window.scrollY - openCloseEle.offsetHeight / 2 + rect.height / 2; // eslint-disable-line

    openCloseEle.style.top = "".concat(top, "px");
    containerEle.style.top = "".concat(top, "px");
    const containerEleLeft = rect.left + window.scrollX;
    containerEle.style.left = "".concat(containerEleLeft, "px");
    const left = containerEleLeft - openCloseEle.offsetWidth;
    openCloseEle.style.left = "".concat(left, "px");
  }, [focusBlock, windowSize]);
  React.useLayoutEffect(layout);
  index.useScrollListener(layout);
  let [isOpen, setIsOpen] = React.useState(false);
  return reactDom.createPortal(core.jsx(React.Fragment, null, core.jsx("div", {
    ref: openCloseRef,
    css: {
      position: 'absolute',
      top: -10000,
      left: -10000
    }
  }, core.jsx("button", {
    type: "button",
    css: {
      borderRadius: '100%',
      border: '1px black solid',
      width: 30,
      height: 30,
      marginRight: 4
    },
    onClick: () => {
      setIsOpen(x => !x);
    }
  }, core.jsx(icons.PlusIcon, {
    css: {
      transition: '50ms transform',
      transform: isOpen ? 'rotateZ(45deg)' : 'rotateZ(0deg)'
    },
    title: isOpen ? 'Close' : 'Open'
  }))), core.jsx("div", {
    css: {
      position: 'absolute',
      top: -10000,
      left: -10000
    },
    ref: containerRef
  }, isOpen && core.jsx("div", null, Object.keys(blocks).map(key => {
    let {
      Sidebar
    } = blocks[key];

    if (!blocks[key].withChrome || Sidebar === undefined) {
      return null;
    }

    return core.jsx(Sidebar, {
      key: key,
      editor: editor,
      blocks: blocks
    });
  })))), document.body);
};
/** @jsx jsx */


let stopPropagation = e => {
  e.stopPropagation();
};

function InnerToolbar(_ref) {
  let {
    blocks,
    editor,
    editorState
  } = _ref;
  return core.jsx("div", {
    css: {
      display: 'flex'
    }
  }, Object.keys(blocks).map(x => blocks[x].withChrome && blocks[x].Toolbar).filter(x => x).reduce((children, Toolbar) => {
    return core.jsx(Toolbar, {
      editor: editor,
      editorState: editorState
    }, children);
  }, core.jsx(React.Fragment, null, Object.keys(marks).map(name => {
    let Icon = marks[name].icon;
    return core.jsx(toolbarComponents.ToolbarButton, {
      label: marks[name].label,
      icon: core.jsx(Icon, null),
      isActive: editorState.activeMarks.some(mark => mark.type === name),
      onClick: () => {
        editor.toggleMark(name);
        editor.focus();
      },
      key: name
    });
  }), core.jsx(toolbarComponents.ToolbarButton, {
    label: "Remove Formatting",
    icon: core.jsx(icons.CircleSlashIcon, null),
    onClick: () => {
      markTypes.forEach(mark => {
        editor.removeMark(mark);
      });
      editor.focus();
    }
  }), Object.keys(blocks).map(type => {
    let ToolbarElement = blocks[type].ToolbarElement;

    if (!blocks[type].withChrome || ToolbarElement === undefined) {
      return null;
    }

    return core.jsx(ToolbarElement, {
      key: type,
      editor: editor,
      editorState: editorState
    });
  }))));
}

const PopperRender = React.forwardRef((_ref2, _ref3) => {
  let {
    scheduleUpdate,
    editorState,
    style,
    children
  } = _ref2;
  let {
    fragment
  } = editorState;
  let shouldShowToolbar = fragment.text !== '';
  let containerRef = React.useRef(null);
  let snapshot = hooks.useMeasure(containerRef);
  React.useLayoutEffect(() => {
    if (shouldShowToolbar) {
      scheduleUpdate();
    }
  }, [scheduleUpdate, editorState, snapshot, shouldShowToolbar]);
  return reactDom.createPortal(core.jsx("div", {
    onMouseDown: stopPropagation,
    ref: node => {
      applyRef(_ref3, node);
      applyRef(containerRef, node);
    },
    style: style,
    css: {
      // this isn't as nice of a transition as i'd like since the time is fixed
      // i think it would better if it was physics based but that would probably
      // be a lot of work for little gain
      // maybe base the transition time on the previous value?
      transition: 'transform 100ms, opacity 100ms'
    }
  }, core.jsx("div", {
    css: {
      backgroundColor: theme.colors.N90,
      padding: 8,
      borderRadius: 6,
      margin: theme.gridSize,
      display: shouldShowToolbar ? 'flex' : 'none'
    }
  }, shouldShowToolbar && children)), document.body);
});

var Toolbar = _ref4 => {
  let {
    editorState,
    blocks,
    editor
  } = _ref4; // this element is created here so that when the popper rerenders
  // the inner toolbar won't have to update

  let children = core.jsx(InnerToolbar, {
    blocks: blocks,
    editor: editor,
    editorState: editorState
  });
  return core.jsx(reactPopper.Popper, {
    placement: "top",
    referenceElement: // the reason we do this rather than having the selection reference
    // be constant is because the selection reference
    // has some internal state and it shouldn't persist between different
    // editor references
    React.useMemo(utils.getSelectionReference, [])
  }, _ref5 => {
    let {
      style,
      ref,
      scheduleUpdate
    } = _ref5;
    return core.jsx(PopperRender, {
      scheduleUpdate,
      editorState,
      style,
      blocks,
      editor,
      ref,
      children
    });
  });
};

function getSchema(blocks) {
  const schema = {
    document: {
      last: {
        type: paragraph.type
      },
      normalize: (editor, _ref) => {
        let {
          code,
          node
        } = _ref;

        switch (code) {
          case 'last_child_type_invalid':
            {
              const paragraph$1 = slate.Block.create(paragraph.type);
              return editor.insertNodeByKey(node.key, node.nodes.size, paragraph$1);
            }
        }
      }
    },
    blocks: {}
  };
  Object.keys(blocks).forEach(type => {
    if (typeof blocks[type].getSchema === 'function') {
      schema.blocks[type] = blocks[type].getSchema({
        blocks
      });
    }
  });
  return schema;
}

function Stories(_ref2) {
  let {
    value: editorState,
    onChange: _onChange,
    blocks,
    className
  } = _ref2;
  let schema = React.useMemo(() => {
    return getSchema(blocks);
  }, [blocks]);
  let plugins$1 = React.useMemo(() => {
    const renderNode = props => {
      let block = blocks[props.node.type];

      if (block) {
        return core.jsx(block.Node, _extends({}, props, {
          blocks: blocks
        }));
      }

      return null;
    };

    return Object.values(blocks).reduce((combinedPlugins, block) => {
      if (typeof block.getPlugins !== 'function') {
        return combinedPlugins;
      }

      return [...combinedPlugins, ...block.getPlugins({
        blocks
      })];
    }, [...plugins, {
      renderBlock: renderNode,
      renderInline: renderNode
    }]);
  }, [blocks]);
  let [editor, setEditor] = index.useStateWithEqualityCheck(null);
  return core.jsx("div", {
    className: className
  }, core.jsx(slateReact.Editor, {
    schema: schema,
    ref: setEditor,
    plugins: plugins$1,
    value: editorState,
    onChange: _ref3 => {
      let {
        value
      } = _ref3;

      _onChange(value);
    }
  }), core.jsx(AddBlock, {
    editor: editor,
    editorState: editorState,
    blocks: blocks
  }), core.jsx(Toolbar, {
    editorState,
    editor,
    blocks
  }));
}
/** @jsx jsx */


let ContentField = _ref => {
  let {
    field,
    value,
    onChange,
    autoFocus,
    errors
  } = _ref;
  const htmlID = "ks-content-editor-".concat(field.path);
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, {
    htmlFor: htmlID,
    field: field,
    errors: errors
  }), core.jsx(fields.FieldInput, null, Object.values(field.getBlocks()).filter(_ref2 => {
    let {
      Provider,
      options
    } = _ref2;
    return Provider && options;
  }).reduce((children, _ref3, index) => {
    let {
      Provider,
      options
    } = _ref3;
    return (// Using index within key is ok here as the blocks never change
      // across renders
      core.jsx(Provider, {
        value: options,
        key: "".concat(htmlID, "-provider-").concat(index)
      }, children)
    );
  }, core.jsx(Stories, {
    key: htmlID,
    blocks: field.getBlocks(),
    value: value,
    onChange: onChange,
    autoFocus: autoFocus,
    id: htmlID,
    css: input.inputStyles({
      isMultiline: true
    })
  }))));
};

exports.default = ContentField;
